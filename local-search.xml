<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>斩波放大器：理论研究笔记</title>
    <link href="/2026/01/27/260127-analysis-of-chopper-opamps/"/>
    <url>/2026/01/27/260127-analysis-of-chopper-opamps/</url>
    
    <content type="html"><![CDATA[<p>提到斩波，第一反应总是电力电子中的斩波。</p><p>但实际上这一说法并不只在升降压变换中使用，在运算放大器中也有一类神奇的分支，叫做斩波运算放大器。</p><p>本篇文章接下来就将简要讲解关于斩波放大器的相关理论，如有疏漏，还望指正。</p><h2 id="稳定精密"><a href="#稳定精密" class="headerlink" title="稳定精密"></a>稳定精密</h2><p>在一些精密电路设计的情景中，通常会对运放的失调和漂移提出很高的要求。</p><p>如果寄希望于集成电路的进步来提高性能，可能最终等来的只会是高昂的成本。然而如果通过模拟信号处理的方式解决，或许可以有更好的解决方法。</p><p>在数十年前，工程师们就面临着这样的问题，于是<strong>斩波放大器</strong>应运而生，在当时的工艺上进一步降低了失调和温漂。</p><p>在 ADI 的一篇应用指南 <strong>MT-055</strong> 中提到，当时最好的双极性放大器的失调电压为 <strong>25μV</strong> ，漂移为 <strong>0.1μV&#x2F;°C</strong> 。然而如果使用斩波运放，就能将失调进一步降低到 <strong>5μV</strong> 以及更小的失调漂移<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="ADI技术指南-斩波稳定(自稳零)精密运算放大器">[1]</span></a></sup>。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h4 id="1-本底噪声"><a href="#1-本底噪声" class="headerlink" title="1.本底噪声"></a>1.本底噪声</h4><p>在深入讲解原理前，先简要说明一下，在精密测量领域，主要存在两类噪声干扰，一类是电路干扰，另一类是本底噪声。</p><p>电路干扰可以通过技术手段尽可能削弱。但闪烁噪声是元器件的固有效应，不仅难以过滤，且功率谱密度随着频率的降低反而会增大。意味着在直流或低频信号处理中，它会直接叠加在有用信号上，难以通过常规滤波手段根除。</p><p><img src="https://s2.loli.net/2026/01/27/9ohCkx8pOalXnHB.png" alt="闪烁噪声的功率频谱图"></p><h4 id="2-自稳零与斩波"><a href="#2-自稳零与斩波" class="headerlink" title="2.自稳零与斩波"></a>2.自稳零与斩波</h4><p>那么斩波结构是如何抑制这些干扰的呢？</p><p>首先要提到的是，目前的斩波运放包含了两种不同的技术，分别是<strong>自稳零与斩波</strong>。他们都有斩波过程，但在原理上大不相同，所以它们更适合被统称为零漂放大器。</p><p>所以本文接下来就会严格区分两类运放，自稳零运放和斩波运放，不再混淆说明为斩波放大器。</p><p>我们先从<strong>自稳零</strong>讲起，先来看一张图，展示了经典的自稳零运放构成。</p><p><img src="https://s2.loli.net/2026/01/27/Br2H8S3RYzvECl1.png" alt="经典自稳零放大器"></p><p>整体电路由 <strong>CHOPPER SWITCH DRIVER</strong> 控制，在运放输入输出端都增加了开关以及串联电容。</p><p>当开关处于 Z 时，电容 C2 直接对地，采样并存储了此时的失调电压误差，使得在正确的信号回路时，该误差可以被电容电压抵消，这样就实现了<strong>抑制运放自身偏置</strong>。此时输出端也执行相同动作，将输出偏置降到最低。当开关接回 S 时，形成输入通路，此时的整个通路上的偏置是趋于零的，这样就达到了我们的目的。这就是自稳零作用，但是单单是自稳零对于 1&#x2F;f 噪声的抑制并不彻底。</p><p>不过这真的是个很巧妙的方法对吧，然而<strong>仔细想想就会发现其实并不合理</strong>，到底是哪里不合理呢？既然采用电容平衡偏置，那么电容充放电的间隔是多少，如何界定？开关难道不会引入额外的噪声？既然有开关频率限制，那这样的运放还剩下多少的有效带宽？更致命的是，这种采样处理方式是否会把高频噪声<strong>折叠</strong>到基带，反而搞砸了原本干净的信号？</p><p>这些新的问题我们暂且按下不表，继续剖析<strong>斩波</strong>的核心原理。</p><p><img src="https://s2.loli.net/2026/01/27/DpcfPZwz6O19rUd.png" alt="斩波放大器流程图"></p><p>如果说自稳零是靠<strong>电容存储</strong>来减去偏差，那么斩波则是进行更高级的<strong>频谱搬移</strong>。</p><p>例如流程图的左上角，信号 $V_{in}$ 的频谱原本分布在极低频段，接下来通过与方波 $M_1(t)$ 相乘，实现频谱搬移。然后再叠加 $V_{OS}+V_N$ 即运放的偏置与噪声，结合成 $V_A$ 的频谱。最后在输出端，经过方波 $M_2(t)$ 的解调，<strong>原信号的频谱返回到初始位置，而噪声信号被搬移至更高频</strong>，接下来只需要低通滤波器的处理，就可以移除噪声的影响。</p><p>经历了两次方波相乘（调制+解调），相当于乘以 $M_1(t) \cdot M_2(t)$。因为两者同步，结果为 1，所以信号<strong>回到了原位</strong>。而噪声只经历了一次相乘（解调），所以从直流（DC）被<strong>搬移到了方波频率及其奇次谐波</strong>上。</p><p>如果觉得不够直观，还可以看下图中的仿真结果<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="吴孙桃,林凡,郭东辉,等.基于斩波技术的CMOS运算放大器失调电压的消除设计[J].半导体技术,2003,(08):60-64.">[2]</span></a></sup>：</p><p><img src="https://s2.loli.net/2026/01/27/jEpGmuhKH5FSPIk.png" alt="斩波放大器仿真"></p><p>从全流程的频谱变化中，可以清晰看到每一步流程的清晰变化，从一个单纯的正弦波再到被方波相乘，再到被解调，然后配合滤波器后得到<strong>更加理想的正弦频谱</strong>。而且对比最开始的频谱和最终的频谱，可以看到尖峰更加独立，而非紧贴着纵轴。也就是说，放大后的正弦摆脱了偏置和 1&#x2F;f 噪声的影响。</p><h4 id="3-斩波并非完美"><a href="#3-斩波并非完美" class="headerlink" title="3.斩波并非完美"></a>3.斩波并非完美</h4><p>讨论了这么多内容，其实斩波技术也并非灵丹妙药，它在解决旧问题的同时，也带来了不少新麻烦。</p><p>首先，<strong>开关调制会引入时钟馈通</strong>，会在信号通路上产生新的斩波纹波。如果处理不好，这些纹波甚至会直接掩盖掉你想测量的微弱信号。</p><p>其次，开关频率受限于运放本身的带宽与稳定性。<strong>斩波频率无法无限提高</strong>，意味着它对高于斩波频率的噪声抑制能力有限。同时，为了保证信号在开关切换瞬间能够准确建立，你必须在带宽与功耗之间做出艰难的取舍。</p><p>因此，实际设计中，常在斩波架构外增加纹波抑制电路、自动校准环路或是辅助放大器，以平衡性能与复杂度。</p><p>关于前面在分析过程中提到的问题，我们会注意到：自稳零使用采样保持技术，由于噪声折回基带，其带内电压噪声较大，这确实是难以弥补的缺陷。而斩波使用信号调制和解调技术，具有更低的基带噪声，但在斩波频率及谐波处产生噪声频谱。因此，斩波放大器更适合直流或低频应用，自稳零放大器则更适合宽带宽应用<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="ADI应用笔记-最低噪声的零漂移放大器提供5.6nV/√Hz电压噪声密度">[3]</span></a></sup>。</p><p>在实际应用中，为了兼顾低频噪声与带宽性能，许多高性能精密运放会采用斩波与自稳零结合的架构，或在斩波核心外增加辅助高速通路，以在抑制漂移与噪声的同时，拓展可用带宽。</p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>斩波技术是一种用于精密测量的有效方式，它通过自稳零与调制-解调机制，将工艺和器件本身的低频噪声滤除，从而在常规工艺基础上实现了接近理论极限的直流精度。尽管仍有不足，但在传感器信号采集、医疗仪器、高精度检测等要求极致失调与低温漂的领域，它仍是不可或缺的关键技术之一。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>ADI技术指南-斩波稳定(自稳零)精密运算放大器<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>吴孙桃,林凡,郭东辉,等.基于斩波技术的CMOS运算放大器失调电压的消除设计[J].半导体技术,2003,(08):60-64.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>ADI应用笔记-最低噪声的零漂移放大器提供5.6nV&#x2F;√Hz电压噪声密度<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Analog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Amplifier</tag>
      
      <tag>Chopper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式三方库指南：以FreeRTOS与LVGL为例</title>
    <link href="/2025/05/21/250521-stm32-freertos-lvgl/"/>
    <url>/2025/05/21/250521-stm32-freertos-lvgl/</url>
    
    <content type="html"><![CDATA[<p>众所周知，嵌入式领域有很多优秀的三方开源库。例如 <a href="https://www.freertos.org/">FreeRTOS</a> 、 <a href="https://lvgl.io/">LVGL</a> 、 <a href="https://arm-software.github.io/CMSIS-DSP">CMSIS-DSP</a> 和 <a href="https://github.com/littlefs-project/littlefs">LittleFS</a> 等，都是大名鼎鼎的嵌入式三方库。利用这些库，可以大幅提升开发效率，轻松实现任务调度、图形界面等功能，无需再陷入裸机编程的重复造轮子中。</p><p>在嵌入式开发中，第三方库的引入方式直接影响项目的可维护性。虽然直接复制源码是最简单的方式，但会带来版本管理、依赖冲突和更新困难等问题。</p><p>主流语言生态大多通过包管理器（如 Python 的 pip、Rust 的 Cargo）解决这类问题。然而在 C&#x2F;C++ 领域，虽然已有 vcpkg、Conan 等优秀工具，但对嵌入式平台（特别是资源受限的 MCU）的支持仍不够完善，许多库缺乏预编译的嵌入式版本。</p><p>因此，我们在很多情况下不得不手动引入三方库来进行开发，本篇博客就将以我个人开发的嵌入式项目 <a href="https://github.com/Marisa9961/SmartBand">SmartBand</a> 为例，讲解笔者在开发过程当中是如何实现以统一方式管理三方库的引入。</p><h2 id="为什么要用CMake"><a href="#为什么要用CMake" class="headerlink" title="为什么要用CMake"></a>为什么要用CMake</h2><blockquote><p>CMake是个一个开源的跨平台自动化建构系统，用来管理软件建置的程序，并不依赖于某特定编译器，并可支持多层目录、多个应用程序与多个函数库。 它用配置文件控制建构过程的方式和Unix的make相似，只是CMake的配置文件取名为CMakeLists.txt。</p></blockquote><p>本次项目的构建系统采用了 <code>CMake+Ninja</code> 的形式，虽然 CMake 在C&#x2F;C++圈子里一直以来广受诟病，且在国内普遍使用 keil 这类 IDE 工具进行编写嵌入式代码的形势下， CMake 的传播度并没有那么广，但其在嵌入式领域的地位依然不容置疑。像 FreeRTOS 和 LVGL 这类成熟的三方库，通常都会提供标准化的 CMakeLists.txt 构建脚本，以便于进行项目的管理和编译。</p><p>再加上 Ninja 在编译性能上的优越性，能够大大提高编译速度，提升编写和调试时的幸福感，因此本项目选择使用了 <code>CMake+Ninja</code> 作为构建系统。</p><p>除此之外，还有一点值得提起的是， CMake 在构建编译信息时可以选择导出 <code>compile_commands.json</code> 。借助 VSCode 中的 <a href="https://clangd.llvm.org/">Clangd</a> 插件，再配合 Clang-Tidy 强大的静态检查功能，能够极大提升编写 C&#x2F;C++ 时的效率和准确性。</p><p>在这一点上其实并非只有 CMake 能够做到，其他构建工具例如 Bazel 和 Meson 也都有类似的功能，包括近来新兴的构建工具 Xmake 也都能够生成 <code>compile_commands.json</code> ，实现更好的静态检查。</p><p>对于这些其他的构建系统，不在本文的讨论范围内，如果各位读者有兴趣可以自行了解。</p><table><thead><tr><th>工具</th><th>嵌入式适用性</th><th>特点</th></tr></thead><tbody><tr><td>CMake</td><td>跨平台，支持裸机和RTOS</td><td>泛用性强，语法复杂</td></tr><tr><td>Make</td><td>需手动编写规则，维护困难</td><td>精神负担重，跨平台性差</td></tr><tr><td>Keil</td><td>仅限ARM，厂商锁定</td><td>依赖厂商，无法导出编译数据库</td></tr></tbody></table><h2 id="如何获取三方库"><a href="#如何获取三方库" class="headerlink" title="如何获取三方库"></a>如何获取三方库</h2><p>一般的开源库都会选择在 <code>Github</code> 存储源代码，所以在 Release 页面就可以获取到当前最新的发行版本。如果没有 Release 发布页面，也可以阅读 README 文件来寻找线索。</p><p>不过虽然在 Github 可以直接获取当前的源码，但这类代码常常是处在版本更迭之间，还未修缮完毕或者还未开发完成的状态，因此并不建议直接引入到自己的项目当中。</p><p>对于维护较为完善的开源项目，他们通常都有更稳定的版本供以选择，叫做 LTS 版（长期支持版本），如下图所示。</p><p><img src="https://s2.loli.net/2025/05/23/mR3jUzWAHPtgsq6.jpg" alt="FreeRTOS官网下载页面"></p><p>这类版本通常是长期支持，不会由于内容更新而引入新的 Bug 。无论是对于商业开发还是个人开发，选择 LTS 版本都有利于长期稳定。</p><p>在开发过程中，如果有足够的理由怀疑三方库出现了问题，也可以在相应仓库的 issue 里提出。但如果只是由于自己对于三方库功能使用不当造成的问题，还是建议自行尝试解决之后再提出，不要无效提问。</p><h2 id="引入方式的选择"><a href="#引入方式的选择" class="headerlink" title="引入方式的选择"></a>引入方式的选择</h2><p>繁琐的话题到此为止，现在开始讲解当拿到一个库之后，如何阅读其中的提示信息，并将库引入到自己的项目。</p><p>接下来，以 FreeRTOS 的 LTS 版本为例讲解，请各位可以试着下载一份源码，并按照步骤对照阅读。</p><p>首先，当我们拿到一份陌生的开源库，应该首先寻找其中的使用示例或者教学文档。按照文档中提示的内容进行，能够尽可能避开错误和误区。</p><p>有些三方开源仓库的构建示例会直接放在根目录当中，也有些会放在 examples 文件夹内，而 FreeRTOS-Kernel 就属于后者。现在打开路径 <code>FreeRTOS-Kernel\examples\cmake_example</code> ，可以看到如下的脚本代码。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(example)<br><br><span class="hljs-keyword">set</span>(FREERTOS_KERNEL_PATH <span class="hljs-string">&quot;../../&quot;</span>)<br><br><span class="hljs-comment"># Add the freertos_config for FreeRTOS-Kernel</span><br><span class="hljs-keyword">add_library</span>(freertos_config INTERFACE)<br><br><span class="hljs-keyword">target_include_directories</span>(freertos_config<br>    INTERFACE<br>    <span class="hljs-string">&quot;../template_configuration&quot;</span><br>)<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> FREERTOS_SMP_EXAMPLE <span class="hljs-keyword">AND</span> FREERTOS_SMP_EXAMPLE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build FreeRTOS SMP example&quot;</span>)<br>    <span class="hljs-comment"># Adding the following configurations to build SMP template port</span><br>    <span class="hljs-keyword">add_compile_options</span>( -DconfigNUMBER_OF_CORES=<span class="hljs-number">2</span> -DconfigUSE_PASSIVE_IDLE_HOOK=<span class="hljs-number">0</span> )<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># Select the heap port.  values between 1-4 will pick a heap.</span><br><span class="hljs-keyword">set</span>(FREERTOS_HEAP <span class="hljs-string">&quot;4&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;&quot;</span> FORCE)<br><br><span class="hljs-comment"># Select the native compile PORT</span><br><span class="hljs-keyword">set</span>(FREERTOS_PORT <span class="hljs-string">&quot;TEMPLATE&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;&quot;</span> FORCE)<br><br><span class="hljs-comment"># Adding the FreeRTOS-Kernel subdirectory</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-variable">$&#123;FREERTOS_KERNEL_PATH&#125;</span> FreeRTOS-Kernel)<br><br><span class="hljs-comment">########################################################################</span><br><span class="hljs-comment"># Overall Compile Options</span><br><span class="hljs-comment"># Note the compile option strategy is to error on everything and then</span><br><span class="hljs-comment"># Per library opt-out of things that are warnings/errors.</span><br><span class="hljs-comment"># This ensures that no matter what strategy for compilation you take, the</span><br><span class="hljs-comment"># builds will still occur.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Only tested with GNU and Clang.</span><br><span class="hljs-comment"># Other options are https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html#variable:CMAKE_%3CLANG%3E_COMPILER_ID</span><br><span class="hljs-comment"># Naming of compilers translation map:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   FreeRTOS    | CMake</span><br><span class="hljs-comment">#   -------------------</span><br><span class="hljs-comment">#   CCS         | ?TBD?</span><br><span class="hljs-comment">#   GCC         | GNU, Clang, *Clang Others?</span><br><span class="hljs-comment">#   IAR         | IAR</span><br><span class="hljs-comment">#   Keil        | ARMCC</span><br><span class="hljs-comment">#   MSVC        | MSVC # Note only for MinGW?</span><br><span class="hljs-comment">#   Renesas     | ?TBD?</span><br><br><span class="hljs-keyword">target_compile_options</span>(freertos_kernel PRIVATE<br>    <span class="hljs-comment">### Gnu/Clang C Options</span><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,GNU&gt;:-fdiagnostics-color=always&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-fcolor-diagnostics&gt;<br><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wall&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wextra&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wpedantic&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Werror&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wconversion&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Weverything&gt;<br><br>    <span class="hljs-comment"># Suppressions required to build clean with clang.</span><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-unused-macros&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-padded&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-missing-variable-declarations&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-covered-switch-default&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-cast-align&gt; )<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>    main.c<br>)<br><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> freertos_kernel freertos_config)<br><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> freertos_kernel PROPERTY C_STANDARD <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>如果读者不了解 CMake 的语法细节，第一次看到这样的脚本应该还是比较茫然的。但是没关系， CMake 的可读性没有那么不堪，各位即便是第一次接触 CMakeLists.txt ，也可以照猫画虎，模仿其中的写法。</p><p>首先，我们会在第一行看到， CMake 脚本必须指定当前使用的 CMake 最低版本，属于固定写法，照抄即可。</p><p>随后会看到脚本指定了 FREERTOS_KERNEL_PATH 的相对路径，这里由于该脚本将自己放在了子路径里，所以需要返回前两级路径，改写的时候就需要将路径指定到当前存储 FreeRTOS 的路径，适当调整。</p><p>然后脚本以库的形式创建了 freertos_config 作为接口库，引入了 <code>../template_configuration</code> 作为头文件路径，而打开相关文件夹， FreeRTOSConfig.h 中就负责定义 FreeRTOS 的配置选项，根据不同的 CPU 类型和架构，进行自定义修改。</p><p>下面这一部分如果不提前了解 FreeRTOS 的设计可能读不明白，这里指定的是如果该 CPU 存在多核处理器，就需要额外增加一些特殊的编译选项。如果只是普通的单核 CPU 就无需考虑这个问题。</p><p>（出自源文件14行）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">DEFINED</span> FREERTOS_SMP_EXAMPLE <span class="hljs-keyword">AND</span> FREERTOS_SMP_EXAMPLE <span class="hljs-keyword">STREQUAL</span> <span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;Build FreeRTOS SMP example&quot;</span>)<br>    <span class="hljs-comment"># Adding the following configurations to build SMP template port</span><br>    <span class="hljs-keyword">add_compile_options</span>( -DconfigNUMBER_OF_CORES=<span class="hljs-number">2</span> -DconfigUSE_PASSIVE_IDLE_HOOK=<span class="hljs-number">0</span> )<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><p>接下来需要选择<a href="https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/09-Memory-management/01-Memory-management">内存管理方案</a>，说白了就是从1~4的四种方案中选择一个作为当前的内存管理。因为FreeRTOS支持动态内存分配，所以需要权衡性能与便利之间的优劣。</p><p>也属于提前了解才能知道如何选择的选项，因此在引入自己的项目前真的需要认真通读一遍功能才行。</p><p>接下来提到 <code>FREERTOS_PORT</code> 可以暂时忽略，不会影响到引用项目的过程。</p><p>而再下一步，就进入到了关于主要代码的引入。</p><p>（出自源文件27行）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Adding the FreeRTOS-Kernel subdirectory</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-variable">$&#123;FREERTOS_KERNEL_PATH&#125;</span> FreeRTOS-Kernel)<br></code></pre></td></tr></table></figure><p>首先是一大段的注释信息，提到关于不同编译器构建时的编译策略和编译器选择。这里默认采用 GCC 来作为编译器，具体可以参考笔者以前写过的 <a href="https://github.com/Marisa9961/stm32-cmake-templete">stm32-cmake-templete</a> 学习。下面提到的一大段都是非常常见的编译选项，想要了解相关内容可以在 <a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html">Option Summary</a> 中查找，不过多展开。这里主要做的内容是根据不同的编译器采取不同的编译选项，并将所有警告视为错误。</p><p>（出自源文件49行）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_compile_options</span>(freertos_kernel PRIVATE<br>    <span class="hljs-comment">### Gnu/Clang C Options</span><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,GNU&gt;:-fdiagnostics-color=always&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-fcolor-diagnostics&gt;<br><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wall&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wextra&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wpedantic&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Werror&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang,GNU&gt;:-Wconversion&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Weverything&gt;<br><br>    <span class="hljs-comment"># Suppressions required to build clean with clang.</span><br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-unused-macros&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-padded&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-missing-variable-declarations&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-covered-switch-default&gt;<br>    $&lt;$&lt;COMPILE_LANG_AND_ID:C,Clang&gt;:-Wno-cast-align&gt; )<br></code></pre></td></tr></table></figure><p>但是在引入到自己的项目时可以直接指定，并不一定完全遵照这个写法，因此虽然看着内容很多很复杂，但其实都可以忽略。</p><p>再接下来就是生成可执行文件，将 <code>main.c</code> （以及你项目中的所有源文件）引入到构建系统，并生成代码。然后将前面创建的两个库一并链接到可执行文件的编译过程中，实现模块间解耦。</p><p>怎么样，这样就读完了脚本，是不是还是不会写（？</p><h2 id="简化引入方式"><a href="#简化引入方式" class="headerlink" title="简化引入方式"></a>简化引入方式</h2><p>具体到笔者所写的项目当中，并没有采用这种复杂的方法。所以读完上面的分析，如果还是不会写也没关系，只需要看接下来的内容就能掌握更通用的引用方法。</p><p>这次以 LVGL 为例讲解，同样的还是推荐下载一份源代码，自行尝试解读其中的构建示例。</p><p>首先先来看 LVGL 引入的时候的文件结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">third-party/LVGL/<br>├── lvgl/               # 官方源码<br>│   ├── src/...         # 源文件<br>│   ├── lv_version.c    # 版本号<br>│   └── lvgl.h          # 通用头文件<br>├── porting/            # 移植代码<br>│   ├── lv_port_disp.c  # 移植屏幕驱动<br>│   ├── lv_port_disp.h<br>│   ├── lv_port_indev.c # 移植触屏驱动<br>│   └── lv_port_indev.h<br>├── CMakeLists.txt      # 子构建脚本<br>└── lv_conf.h           # lvgl设置<br></code></pre></td></tr></table></figure><p>注意，其中只有 <code>porting/</code> 与 <code>lv_conf.h</code> 是需要手动设置的，其他文件内容原则上不应该随意改动。</p><p>首先是 <code>lvgl/</code> 目录，这里存放从官网下载的原始代码，包括 <code>src/</code> 子目录里的核心源代码、 <code>lv_version.c</code> 版本文件以及 <code>lvgl.h</code> 主头文件。这些文件组成了 LVGL 的核心功能，一般不应该修改这里面的内容，这样以后升级版本时直接替换整个目录就行。</p><p>然后是 <code>porting</code> 目录，这里放的是需要自己编写的硬件适配代码。主要包含两个关键文件： <code>lv_port_disp.c</code> 用于实现屏幕显示驱动，负责初始化屏幕、管理缓冲区和刷新画面； <code>lv_port_indev.c</code> 用于实现输入设备驱动，处理触摸屏或者按键的输入。这两个文件需要根据具体硬件来编写，比如在 STM32 上可能要操作 LTDC 或者 SPI 接口。</p><p>还有一个重要的 <code>lv_conf.h</code> 配置文件，这个文件用来设置 LVGL 的各项参数。比如在这里定义屏幕的分辨率、颜色深度，启用或禁用各种功能模块，调整内存池大小等。这个文件直接影响 LVGL 的运行效果和资源占用。</p><p>最后是 <code>CMakeLists.txt</code> 构建脚本，它负责把这些部分组织起来。脚本里会明确定义哪些是官方源代码，哪些是自己写的移植代码，并确保所有头文件路径都正确设置。这样构建系统就能把各个部分正确编译链接到一起。</p><p>这种组织方式的好处很明显：官方代码和自己写的代码完全分开，升级时互不影响；不同的硬件平台可以通过不同的 <code>porting</code> 实现来支持；通过修改配置文件就能调整功能，不需要动核心代码。</p><hr><p>接下来就重点讲解子构建脚本的内容应当如何编写：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Set the LVGL root directory</span><br><span class="hljs-keyword">set</span>(LVGL_ROOT_DIR   <span class="hljs-string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/third-party/LVGL&quot;</span>)<br><span class="hljs-keyword">set</span>(LVGL_SRC_DIR    <span class="hljs-string">&quot;$&#123;LVGL_ROOT_DIR&#125;/lvgl&quot;</span>)<br><span class="hljs-keyword">set</span>(LVGL_PORT_DIR   <span class="hljs-string">&quot;$&#123;LVGL_ROOT_DIR&#125;/porting&quot;</span>)<br><br><span class="hljs-comment"># Build LVGL library</span><br><span class="hljs-keyword">add_library</span>(lvgl INTERFACE)<br><br><span class="hljs-comment"># Set sources used for LVGL components</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE SOURCES<br>    <span class="hljs-variable">$&#123;LVGL_SRC_DIR&#125;</span>/src/*.c <br>    <span class="hljs-variable">$&#123;LVGL_SRC_DIR&#125;</span>/src/*.S <br>    <span class="hljs-variable">$&#123;LVGL_PORT_DIR&#125;</span>/*.c<br>)<br><br><span class="hljs-keyword">target_sources</span>(lvgl INTERFACE<br>    <span class="hljs-variable">$&#123;SOURCES&#125;</span><br>)<br><br><span class="hljs-comment"># Include root and optional parent path of LV_CONF_PATH</span><br><span class="hljs-keyword">target_include_directories</span>(lvgl INTERFACE<br>    <span class="hljs-variable">$&#123;LVGL_ROOT_DIR&#125;</span><br>)<br></code></pre></td></tr></table></figure><p>内容较为简单易懂，主要执行的步骤为建立路径变量、创建接口库、添加源文件内容、添加头文件路径。这样就能快速将三方库文件引入到自己的项目中，而且具有良好的隔离性，每个三方库都拥有自己的子构建脚本，将所有的子构建脚本汇总在根目录下的 <code>CMakeLists.txt</code> 中使用诸如 <code>add_subdirectory(third-party/LVGL)</code> 这样的函数就能快速引入 LVGL 的库文件。</p><p>总而言之，将三方库代码统一存放在 <code>third-party</code> 当中，并在每个库内建立 <code>CMakeLists.txt</code> 来进行管理，能提升项目的条理性。</p><p>非常简单的一段脚本对吧，掌握了基本 CMake 语法之后可以轻易读懂。所以我说的简化引入方式并没有什么神秘之处。因此，比起寻找更简洁的构建方式，不如先从项目的文件管理下手，将引入三方库的工作进行解耦设计，这样就能使得代码设计更加简洁。</p><h2 id="补充点没讲到的"><a href="#补充点没讲到的" class="headerlink" title="补充点没讲到的"></a>补充点没讲到的</h2><p>在 <a href="https://github.com/Marisa9961/SmartBand">SmartBand</a> 项目仓库中，我总共引入了 LVGL 、 LittleFS ，并没有出现 FreeRTOS 的源文件和构建脚本。这是因为 STM32CubeMX 中提供的 CMSIS-RTOS 兼容层已经包含了这些源代码，而这些源代码又被我的 <code>cmake/stm32cubemx.cmake</code> 所包含，所以实际上可以省去这个步骤。</p><p>另一个没有在本篇博客中举例讲解的 LittleFS 可以自行查看，原理大致相同，但是其源代码并不提供接口耦合， <code>LittleFS/porting</code> 是我仿照 LVGL 的接口自行编写的，如有想要借鉴的可以自行研究。</p><blockquote><p>在本文结束后的半年时间里，笔者偶然了解到了 RT-Thread 对于嵌入式包管理的尝试<br>各位如果有兴趣的话可以自行尝试了解 <a href="https://github.com/RT-Thread/env">https://github.com/RT-Thread/env</a></p></blockquote><hr><p><strong>推荐阅读</strong></p><p>CMake Tutorial: <a href="https://cmake.org/cmake/help/latest/guide/tutorial/">https://cmake.org/cmake/help/latest/guide/tutorial/</a></p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>LVGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁相放大器：理论研究笔记</title>
    <link href="/2025/01/10/250110-analysis-of-lock-in-amplifier/"/>
    <url>/2025/01/10/250110-analysis-of-lock-in-amplifier/</url>
    
    <content type="html"><![CDATA[<p>最近重新整理之前做过的电赛题目资料时，回忆起了这个有趣的话题。</p><p>所谓<strong>锁相放大器</strong>，就是能够在一片噪声的干扰之中正确找到目标信号，并对其进行分离和增益的一种放大器。</p><p>听起来相当魔幻对吧，实际上这样的电路实现起来也确实会困难重重，条件非常苛刻。但是锁相放大器依然还是有很丰富的理论研究价值，接下来就来进行分析。</p><p><img src="https://s2.loli.net/2025/01/10/EeWqYN8mVCcB2dS.jpg" alt="锁相放大器（图源 Wikipedia）"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>锁相放大器，英文全称<strong>Lock-in Amplifier</strong>，又称<strong>LIA</strong>。</p><p><img src="https://s2.loli.net/2025/01/10/EkdXURqTJbDLHif.jpg" alt="锁相放大器原理图示（图源 Wikipedia）"></p><p>利用三角函数积化和差的思想，产生一路正弦信号与输入信号相乘，得到如下结果：</p><div style="text-align: left">    $$    \begin{align}        &A_1\sin(\omega + \varphi) \cdot A_2\sin(\omega + \varphi) \\        &= \frac{1}{2} A_1 A_2 \{\cos[(\omega + \varphi) - (\omega + \varphi)] - \cos[(\omega + \varphi) + (\omega + \varphi)]\} \\        &= \frac{1}{2} A_1 A_2 \left[1 - \cos(2\omega + 2\varphi)\right]    \end{align}    $$</div><p>只要保证正弦信号与目标信号<strong>同频同相</strong>，就能得出直流信号与两倍频的叠加波。</p><p>然后利用低通滤波器滤除 $ -\frac{1}{2} A_1 A_2 \cos(2\omega + 2\varphi) $ ，得到直流分量 $ \frac{1}{2} A_1 A_2 $ 。</p><p><img src="https://s2.loli.net/2025/01/10/whASIbiyHMEd4ac.png" alt="除法器电路（图源新概念模拟电路II P46）"></p><p>对于该直流分量的处理就简单了，因为 $ A_1 $ 是已知信号，利用<strong>除法器</strong>即可将 $ A_2 $ 准确还原出来。<br>（提示：图中右上角的元件是乘法器，$ U_{I1} $ 和 $ U_{I2} $ 是输入电压，$ U_{O} $ 是除法结果，即利用乘法器和运放即可搭出除法器电路）</p><p>或者直接将信号采样到单片机，再在内部进行除法运算，即可得到目标信号的采样数据。</p><h2 id="相位差问题"><a href="#相位差问题" class="headerlink" title="相位差问题"></a>相位差问题</h2><p>有人可能会疑惑，这不是多此一举吗，既然我都知道目标信号的频率了，做这个还原有什么意义？</p><p><strong>其实并不是这样。</strong></p><p>首先我们先规定一下，需要还原出来的信号叫做“目标信号”，本地产生的信号的叫“参考信号”。</p><p>在实际应用中，虽然不能得知目标信号具体的频率，但我们可以在一个范围内<strong>扫频</strong>来逼近目标频率。</p><p>所谓扫频就是用频率步进变化的正弦波去逐次逼近结果，<strong>只有频率接近目标信号时</strong>，锁相放大器的结果才会达到绝对值最大，此时才能确定目标信号的频率。</p><p>这里就可以将上面的公式推广到一般情况。</p><div style="text-align: left">    $$    \begin{align}        &A_1\sin(\omega_1 + \varphi_1) \cdot A_2\sin(\omega_2 + \varphi_2) \\        &= \frac{1}{2} A_1 A_2 \{\cos[(\omega_1 + \varphi_1) - (\omega_2 + \varphi_2)] - \cos[(\omega_1 + \varphi_1) + (\omega_2 + \varphi_2)]\}    \end{align}    $$</div><p>注意到，当 $ \omega_1 + \varphi_1 $ 与 $ \omega_2 + \varphi_2 $ 极为接近时，两者相减结果趋于0，使得 $ \cos $ 趋近于1，也就可以将 $ \frac{1}{2} A_1 A_2 \cos[(\omega_1 + \varphi_1) - (\omega_2 + \varphi_2)] $ 近似看作<strong>直流分量</strong>。</p><p>不过这里只能说是“趋近”，而不能是达到完全相等。因为尽管待测信号源输出的是 $ 1khz $ 的正弦波，系统主动输出的也是 $ 1khz $ 的正弦波，由于时钟源的差异，两者几乎不可能做到完全同步。频率之差可能最开始很小，但随着时间推移，两者的相位最终会逐渐错开。况且常见时钟源受到电压、温度等因素影响都比较大，因此频率偏移是一个重要因素。</p><p>这时就需要再次扫频校准，带来了麻烦，那么能不能有合理的办法解决呢？</p><h2 id="双相位法"><a href="#双相位法" class="headerlink" title="双相位法"></a>双相位法</h2><p>在《<strong>新概念模拟电路</strong>》的相关章节中（<strong>第四册 P231 电荷放大器和锁定放大器</strong>）就提到了<strong>双相位法</strong>。</p><p>双相位法在原先的基础上，增加了一路同频的参考信号来进行相乘，但该信号需要进行90°的相移。</p><p>然后再将两路正交的正弦波分别相乘并滤波，得出 $ U_{O1} $ 和 $ U_{O2} $ 两路信号。</p><p><img src="https://s2.loli.net/2025/01/10/H1qCIrwfL3b8nOD.png" alt="双相位法（图源新概念模拟电路IV P237）"></p><p>系统最终会得到 $ U_{OA} $ 和 $ U_{OB} $ 两个分量，这两者虽然不是我们想要的的直流分量，但是将其平方和开根就可得到新的结果 $ U_O $ ：</p><div style="text-align: left">    $$    \begin{align}        U_O &= \sqrt{U_{OA}^{2} + U_{OB}^{2}} \\        &= \frac{1}{2} A_{m1} A_{m2} \sqrt{\sin(\varphi_{1A} - \varphi_2)^2+\cos(\varphi_{1A} - \varphi_2)^2} \\        &= \frac{1}{2} A_{m1} A_{m2}    \end{align}    $$</div><p>由此就可在相位关系未知的情况下得出直流分量 $ \frac{1}{2} A_{m1} A_{m2} $ 的值，这样就巧妙的解决了上述问题。</p><p>（注意书上图片中最终结果有误，写成了 $ U_O &#x3D; \frac{1}{2} A_{m2} A_{m2} $，这里应该只是笔误）</p><p>不仅如此，我们还可根据 $ U_{OA} $ 和 $ U_{OB} $ 的关系求出待测信号的相位差：</p><p>$$ \tan(\varphi_{1A} - \varphi_2) &#x3D; \cfrac{\sin(\varphi_{1A} - \varphi_2)}{\cos(\varphi_{1A} - \varphi_2)} &#x3D; \cfrac{U_{OA}}{U_{OB}} $$</p><p>接下来只需要利用 $ \arctan(\cfrac{U_{OA}}{U_{OB}}) $ 就可得到相位差。</p><p><strong>实在是太神奇了。</strong></p><p>双相位法真是一种非常巧妙的解决办法，我们不需要严格匹配目标的相位与实际的相位，就能准确求出直流分量，甚至还能顺带求出相位差。而原理也并不复杂，仅仅是掌握三角变换的特性就能轻松理解。</p><p>这些三角变换并不困难，甚至只需要初高中的水平就能推导得出。但当其与电路设计结合在一起时，还是不得不佩服这些数学家的小把戏。</p><p>上述内容针对锁定放大器的原理进行了改进，但是在实际应用的过程中还会遇到新的问题，接下来就来看看实践改进应该如何分析？</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>在实践部分，书中提到了移相时会遇到的问题。</p><blockquote><p>上述方法，理论分析头头是道，但实现起来很困难。其中最大的难点在于90°移相。我们知道，全通滤波器可以实现移相，但它的标准功能是，对不同频率实施不同的移相而要对任意给定的频率都能实现90°相移，且幅度不发生变化，在模拟电路中是很难做到的。</p></blockquote><p>书中以模拟电路的视角来考虑相位问题，确实不太容易实现移相。但如果从实际应用的角度，在一些要求没那么高的场合，完全可以考虑利用多通道DDS直接设置两路正交的正弦波来解决这个问题，因此这里可能并不是最困难的地方。</p><p>但在另一方面，双相位法需要两路相同的乘法器电路来实现，而乘法器本身就是<strong>价格昂贵</strong>且使用条件比较苛刻的精密元件，很多情况下都没有机会用上这么奢侈的方案。那么有没有办法能替代掉呢？</p><p><strong>还真有。</strong></p><p>将正弦信号替换为方波信号，就能达到相同的效果。</p><p>仔细思考一下这套系统中的难点如何解决：</p><ul><li><p>首先参考信号要易于产生和调相，方波信号其实就是0和1的周期性变换，非常易于产生和调相。</p></li><li><p>其次就是方波可以在一定程度上等效于乘法：如果我们之间将方波与任意信号相乘，会发现其实当方波为1时，结果就是任意信号本身；而当方波为0时，乘法结果也就是零。</p></li></ul><p>这个效果似乎很眼熟？</p><p>这不就是模拟开关的效果了吗？</p><p>也就是说利用方波控制模拟开关，再间接控制输入信号导通，能达到与乘法器同样的效果。</p><p>接下来给出方波双相位法的示意图：</p><p><img src="https://s2.loli.net/2025/01/10/kG4I6Dz2g8oTRAc.png" alt="双相位法（图源新概念模拟电路IV P239）"></p><p>这里的大体思路还是与原方案相同，都是将输入信号与待测信号做乘法，将低通滤波后的结果进行平方和开根号，即可得到最后的 $ U_O $ 。</p><p>只是在如下这些细节部分有所不同：</p><ol><li><p>首先是方波与正弦波相乘结果的直流系数不太相同，达到了<strong>0.6366</strong>（图中 $ A_{m1} &#x3D; 1 $ ）</p></li><li><p>其次方波相乘并不能直接等效于乘零，而是应该接上反相器，等效为一个正负对称的方波。</p></li></ol><p>不过上述细节并不影响方案的整体思路，系数的差异可以通过放大器系数的调节解决。</p><p>其中关于直流系数的差异，即<strong>0.6366</strong>到底是怎么得出的，有兴趣的可以自行在书中寻找推导过程，这里并不做深入讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Analog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Noise</tag>
      
      <tag>Amplifier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART通信：IDLE+DMA的优化技巧</title>
    <link href="/2024/07/15/240715-stm32-spi-communicate/"/>
    <url>/2024/07/15/240715-stm32-spi-communicate/</url>
    
    <content type="html"><![CDATA[<p>最近在做UART与上位机通信的时候，注意到STM32的UART居然支持硬件IDLE。</p><p>于是就尝试了一把 <code>IDLE+DMA</code> 的模式，使得设备可以自动在接收空闲时唤起中断，DMA直接搬运数据到内存，实现任意长度的命令或是数据都能自动完成接收和回调。</p><h2 id="IDLE模式"><a href="#IDLE模式" class="headerlink" title="IDLE模式"></a>IDLE模式</h2><p>首先来讲讲什么是IDLE模式？</p><p>所谓的IDLE就是not working or being used，翻译成中文就是闲置状态。当UART的Rx总线收到持续信息时，会在最后一帧数据结束后进行检查，当出现了至少一帧的闲置电平，就会唤醒相关的回调函数管理。也就实现了无论数据长度有多长，都会自动停止接收并进入中断处理，非常方便。</p><p>网上某些过时的教程会告诉你，UART的IDLE模式要通过以下这样的语句开启：<br><code>__HAL_UART_ENABLE_IT(&amp;huart1, UART_IT_IDLE)</code></p><p>其实HAL库目前已经将IDLE的相关功能封装成了正式函数，并且已经包含在下列库文件中。</p><ul><li>stm32g4xx_hal_uart_ex.c</li><li>stm32g4xx_hal_uart_ex.h</li></ul><p>现在打开IDLE模式的正确姿势应该是：<br><code>HAL_UARTEx_ReceiveToIdle</code><br><code>HAL_UARTEx_ReceiveToIdle_IT</code><br><code>HAL_UARTEx_ReceiveToIdle_DMA</code></p><p>这些函数会自动开启IDLE功能，并启用相关的中断。IDLE接收本身就很方便，但如果再加上DMA辅助搬运数据，就更能为CPU分担压力，节省计算资源。</p><p>然而如果我们真的想写一个足够健壮且高效的串口处理程序，不用的时候就安静的待在一边，数据来了的时候就自动接收、自动搬运、自动停止、自动通知CPU处理。</p><p><strong>那可能还真没那么好写</strong>，因为一旦牵扯到DMA，问题就会开始变得复杂。</p><p>当一组数据被传递过来，而CPU还在运算其他优先级更高的任务，来不及处理这批数据。紧接着又来了一批数据把上一批数据全部覆盖掉，此时的CPU就浑然不知，只做了一批数据的回调处理就继续干别的去了，这样就导致了前一批数据丢失。</p><h2 id="DMA中断模型"><a href="#DMA中断模型" class="headerlink" title="DMA中断模型"></a>DMA中断模型</h2><p>其实数据被反复覆盖的问题在HAL库设计之初就有被考虑到过，HAL库也给出了相应的解决方案：<br><code>HAL_UART_RxHalfCpltCallback</code><br><code>HAL_UART_RxCpltCallback</code></p><p>现在我们考虑如下的情形：</p><p>首先使能 <code>DMA</code> 的 <code>Circular</code> 模式，开启数据的循环接收。随后创建一个 <code>Buffer[20]</code> 用来接收数据，并用 <code>R</code> 和 <code>W</code> 来标记当前缓冲区内读指针和写指针。且当 <code>Buffer[20]</code> 被填写到一半或者填满时，就触发对应的回调函数 <code>HT</code> 和 <code>TC</code> ；每当本次数据接收完毕，<code>I</code> 就会被触发，也就是空闲中断回调。</p><p>此时可以将所有的内存写入问题归纳为如下五种模型<a href="https://github.com/MaJerle/stm32-usart-uart-dma-rx-tx">(图源)</a>：</p><p><img src="https://s2.loli.net/2024/07/23/O2lIsvEq5QtGdAJ.png" alt="DMA Circular"></p><ul><li><p>情况 A:<br>收到10字节，触发 <code>HT</code> ，随后处理已接收的数据。</p></li><li><p>情况 B:<br>收到10字节，触发 <code>TC</code> ，处理现在从最后已知位置 <code>R</code> 开始，直到内存结束。DMA 处于循环模式，因此它会从缓冲区的开头继续传输数据，覆盖原有数据。</p></li><li><p>情况 C:<br>收到10字节，当接收到前<strong>6</strong>字节时，触发了 <code>HT</code> 。但在接下来<strong>4</strong>字节传输后，将再次触发 <code>I</code> 。</p></li><li><p>情况 D:<br>收到10字节，前<strong>4</strong>字节会触发 <code>TC</code> ，随后缓冲区溢出，回到顶点重新覆盖旧数据。接下来<strong>6</strong>字节成功传输到内存后，触发 <code>I</code> 。</p></li><li><p>情况 E:<br>收到<strong>30</strong>字节，超出缓冲区能处理的范围，有<strong>10</strong>字节会被直接覆盖。这时 <code>HT</code> 和 <code>TC</code> 就起到了作用，当刚好发到20个字节时，<code>HT</code> 和 <code>TC</code> 会被分别触发一次。而若这两次都已经被触发过了，还在有新的数据进入，并且一直覆盖过了原先的 <code>R</code> 指针，那么就说明发生了错误，需要及时进行相应的错误处理。</p></li></ul><p>由上述模型可知，HAL库之所以只提供 <code>HT</code> 和 <code>TC</code> 这两个节点的回调，正是因为这两点能够满足最基本的<strong>数据溢出检查</strong>。</p><p>即便数据溢出到能覆盖两轮以上(对于上述的模型也就是在20字节缓冲区里发送40字节及以上)，我们也可以凭中断被多次触发，而数据未被CPU及时处理，来判断UART接收出现了错误。</p><h2 id="Callback问题"><a href="#Callback问题" class="headerlink" title="Callback问题"></a>Callback问题</h2><p>虽然上述想法很好，但是实践起来还是会有一些问题。</p><p>首先IDLE中断会触发下列函数的回调：<br><code>HAL_UART_RxCpltCallback</code><br><code>HAL_UART_RxHalfCpltCallback</code><br><code>HAL_UARTEx_RxEventCallback</code></p><p>那么考虑以下的情况，当数据恰好被填到一半的时候，理应有两次中断被调用：</p><ol><li>当数据被填充到一半时唤起“HAL_UART_RxHalfCpltCallback”</li><li>随后Rx总线空闲，唤起“HAL_UARTEx_RxEventCallback”</li></ol><p>同理，被恰好填充到满时也应该有两次调用，对吧？</p><p><strong>但是事实并非如此</strong>，被恰好填充到满时，数据缓冲区会被重置，并从缓冲区顶重新写入，此时IDLE中断并不会被唤起。</p><p>这就给程序的判断造成了难题，是否能在这里截断？如果数据还没完，就直接将现在接收到的数据交给CPU，那得到的结果肯定是不正确的。</p><p>另一个问题是，两次中断之间是肯定有时间间隙的。像H7这样的芯片，在满主频且串口压力较小的情况下，是真的可以做到在两次中断之间把现有截断的数据处理完成，进而导致结果错误的。</p><p>这些问题的出现既有可能是HAL库设计不周，也有可能 UART IDLE 根本不是这样设计来用的。笔者本人水平一般，暂时没有得出有说服力的结论。之后关于这个问题若是有什么进展，会及时在这篇博客更新。</p><hr><p>倒是有一些比较偷懒的办法解决上述冲突，虽然不太优雅就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Cpp">__HAL_DMA_DISABLE_IT(&amp;DMA_RX_HANDLE, DMA_IT_HT);<br>__HAL_DMA_DISABLE_IT(&amp;DMA_RX_HANDLE, DMA_IT_TC);<br></code></pre></td></tr></table></figure><p>用上述两个函数可以禁用 <code>HT</code> 和 <code>TC</code> 中断，此时就只有 UART IDLE 的中断会被调用。虽然此时缓冲区被恰好填充完整时，依然不会有任何中断会被调用。但上位机可以任意发送一位信息，唤起IDLE中断让其进行处理。</p>]]></content>
    
    
    <categories>
      
      <category>Embedded</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
      <tag>SPI</tag>
      
      <tag>UART</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADF435x锁相环驱动调试</title>
    <link href="/2024/05/12/240512-adf435x-introduce/"/>
    <url>/2024/05/12/240512-adf435x-introduce/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在做ADF4351锁相环模块，调试过程中遇到了很多问题，因为锁相环本身就结构复杂，所以程序写的比较花费精力。然而，在多方查找参考资料的过程中，注意到了ADI官网提供了调试软件的免费下载。</p><p><a href="https://www.analog.com/en/resources/evaluation-hardware-and-software/evaluation-boards-kits/eval-adf4351.html">ADF4351 Evaluation Software</a></p><p><img src="https://s2.loli.net/2024/06/10/a6mp3g7nybRzKjc.png" alt="初始界面"></p><p>这是ADI官方提供的芯片评估板配套使用软件，可以拿来很方便的计算寄存器参数。可以利用这里生成的参数直接写入MCU并发送给ADF4351。</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>首先在 <strong>Select Devices and Connection</strong> 选择芯片型号，随后进入 <strong>Main Control</strong> 进行参数的设置。</p><p>对于最基础的倍频功能，只需要修改如下几个圈起来的地方即可。</p><p>例如板载晶振为24M，且输出要求240M：</p><p><img src="https://s2.loli.net/2024/06/10/anMCm1BUEjPkIZH.png" alt="RF设置"></p><p>这里的多数选项都不需要额外注意，芯片手册里写的很详细。需要注意的是总公式里的 <strong>Div</strong> 并不都在 <strong>Reg0</strong> 和 <strong>Reg1</strong> 当中配置，而是在 <strong>Reg4</strong> 当中出现。</p><p>所以其实针对初始状态进行一次设置之后，只需要修改 <strong>Reg0</strong> <strong>Reg1</strong> <strong>Reg4</strong> 的内容即可实现步进倍频的功能。</p><p>其余的配置参数可以任意尝试，来帮助理解对应关系。结合手册和软件就能快速掌握芯片的基本用法。</p><p>以下是我的工程中的主体代码，仅供参考。方法实现过于简单，就不一一展示了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">namespace</span> adf4351 &#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> REG_SIZE&#123;<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> MAX_OUT_FREQ&#123;<span class="hljs-number">4400</span>&#125;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> MIN_OUT_FREQ&#123;<span class="hljs-number">35</span>&#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pll</span> &#123;<br>       <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Pll</span>();<br>        ~<span class="hljs-built_in">Pll</span>() = <span class="hljs-keyword">default</span>;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setInput</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; freq)</span></span>;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setFreq</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; freq)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setPhase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span>&amp; phase)</span></span>;<br>        [[nodiscard]] <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">getFreq</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>        [[nodiscard]] <span class="hljs-function"><span class="hljs-type">uint16_t</span> <span class="hljs-title">getPhase</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>       <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">float</span> input_freq_&#123;<span class="hljs-number">24</span>&#125;;<br>        <span class="hljs-type">float</span> output_freq_&#123;<span class="hljs-number">240</span>&#125;;<br>        <span class="hljs-type">uint16_t</span> output_phase_&#123;<span class="hljs-number">0</span>&#125;;<br>        std::array&lt;<span class="hljs-type">uint32_t</span>, REG_SIZE&gt; reg;<br>        <br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>RF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PLL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好，世界</title>
    <link href="/2024/04/28/240428-hello-world/"/>
    <url>/2024/04/28/240428-hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="你好，世界"><a href="#你好，世界" class="headerlink" title="你好，世界"></a>你好，世界</h2><p>这是一个利用Hexo框架搭建的个人博客网站，使用的主题为<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><p>鉴于本人并不擅长前端开发，搭建此博客仅凭兴趣，只为随缘分享一些技术相关的内容。</p><p>您在本站即将看到关于硬件设计、嵌入式开发以及其他零散的技术内容。</p><p>还需提醒的是，本人水平不足，技术有限，文中如有纰漏，欢迎指出并修正。</p><p><img src="https://s2.loli.net/2024/06/10/DBjA5WEeOarhmgs.jpg" alt="35678607" title="pid:35678607"></p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
